Freeモナドの概要
================

目次
----

モナドのおさらい
----------------

つぎのような関数が定義できるような型mをモナドと呼ぶ。

```hs
pure :: a -> m a
(>>=) :: m a -> (a -> m b) -> m b
```

おなじことを、つぎの、みっつの関数でも表現できる。

```hs
fmap :: (a -> b) -> m a -> m b
pure :: a -> m a
join :: m (m a) -> m a
```

このことは、つぎのように示すことができる。

```hs
fmap = flip (>>=) . (pure .)
join = (>>= id)

(>>=) = flip $ (join .) . fmap
```

Freeモナドを理解するうえで、モナドがfmap, pure, joinのみっつで表現される
という側面をおさえておくことが、助けとなる。
モナドとは、つぎのような操作ができる文脈mと言える。

* 値に文脈をつけることができる (pure :: a -> m a)
* 文脈のなかの値に関数を適用できる (fmap :: (a -> b) -> m a -> m b)
* 二重になった文脈を一段の文脈にほどくことができる (join :: m (m a) -> m a)

ファンクタからモナドへ
-----------------------

ファンクタとは、つぎのような関数を持つ型fのことである。

```hs
fmap :: (a -> b) -> f a -> f b
```

つまり、モナドとはファンクタであるような型fに、さらにつぎの、
ふたつの関数を追加したものである。

```hs
pure :: a -> m a
join :: m (m a) -> m a
```

モナドにできて、ファンクタにできないこと: リストの例
----------------------------------------------------

ここで、つぎのような演算子を定義する。

```hs:listExample.hs
(>>-) :: Functor f => f a -> (a -> f b) -> f (f b)
(>>-) = flip fmap
```

ファイルlistExample.hsに定義しておく。
モナドのbind関数と比較してみよう。

```hs
(>>-) :: Functof f => f a -> (a -> f b) -> f (f b)
(>>=) :: Monad m => m a -> (a -> m b) -> m b
```

ファンクタのほうの演算子では、文脈が二重になっているのがわかる。
ファイルlistExample.hsを読み込んで、つぎのように試してみよう。

```hs
> [1, 2] >>= \x -> "abc" >>= \y -> [False, True] >>= \z -> [(x, y, z)]
[(1,'a',False),(1,'a',True),(1,'b',False),(1,'b',True),(1,'c',False),
(1,'c',True),(2,'a',False),(2,'a',True),(2,'b',False),(2,'b',True),
(2,'c',False),(2,'c',True)]
> [1, 2] >>- \x -> "abc" >>- \y -> [False, True] >>- \z -> [(x, y, z)]
[[[[(1,'a',False)],[(1,'a',True)]],[[(1,'b',False)],[(1,'b',True)]],
[[(1,'c',False)],[(1,'c',True)]]],[[[(2,'a',False)],[(2,'a',True)]],
[[(2,'b',False)],[(2,'b',True)]],[[(2,'c',False)],[(2,'c',True)]]]]
```

ファンクタのほうの演算では、リストがネストしてしまっている。

Freeモナドとは
--------------

もとの型がファンクタであれば、それを変換してモナドにすることができるデータ型。
つぎのような定義となる。

```hs:freeMonad.hs
data Free t a
        = Pure a
        | Join (t (Free t a))
```

再帰的な定義となっていて、たとえばリストでは、
つぎのような値を定義することができる。

```hs
Join [Join [Join [Join [Pure True]]]] :: Free [] Bool
```

Join [...]を何重に入れ子にしても、おなじ型Free [] Boolとして、
あつかうことができる。
つまり、もとの型によるデータ構造が、何重にネストしてしまったとしても、
この型の値に変換することで、ネストのない型として、
あつかうことができるということになる。

```hs
[[[[True]]]] :: [[[[Bool]]]]
Join [Join [Join [Join [Pure True]]]] :: Free [] Bool
```

値はネストしても、型はネストしない。
このように、値はネストしたままで、関数joinと同様の効果を、得ることができる。

Freeモナドで、いろいろなモナドを作る
------------------------------------

```hs:hoge.hs
hello = hoge
hige = hoge
```
