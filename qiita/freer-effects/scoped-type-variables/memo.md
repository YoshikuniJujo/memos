memo
====

ScopedTypeVariables拡張が必要。
これは以下のコードで必要になる。

```hs
newtype P (t :: * -> *) (ts :: [* -> *]) = P { unP :: Word }

class Member (t :: * -> *) (ts :: [* -> *]) wehre elemNo :: P t ts
instance Member (t ': ts) where
	elemNo = P 0
instance {-# OVERLAPPABLE #-} Member t ts => Member t (_t' ': ts) where
	elemNo = P $ 1 + unP (elemNo :: P t ts)
```

とりあえず僕の知るかぎりでは2つの側面がある。

* 型変数のスコープを広げる
* パターンマッチの変数に型シグネチャをつけることができる

とりあえず後者の説明はしない。
前者の説明だけする。

学んだこと
----------

とりあえず、原論文とGHCのドキュメントを読んだ。
原論文は現在のGHCのやりかたとは異なるやりかたをしている。

### 導入

* where節で型宣言できない例を挙げる

### 関数定義

* 型宣言でforall ...として明示的に型変数を導入することで、
	関数全体を型変数のスコープとすることができる
* スコープ内ですでに導入されている型変数については、
	暗黙のforallがつかない
* 引数に関しては、もうひとつのやりかたがあり、
	そちらのやりかただと存在型についても型変数を使うことができる

### 型クラス宣言

* 型クラス宣言の頭部で導入された型変数のスコープは、
	型クラス宣言全体
* これはScopedTypeVariables拡張をしていなくても同様

### インスタンス宣言

* インスタンス宣言の頭部で導入された型変数のスコープは、
	インスタンス宣言全体
* ScopedTypeVariables拡張によりスコープが広がった結果として、そうなる
