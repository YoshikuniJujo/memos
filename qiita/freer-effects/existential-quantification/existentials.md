Freer Effectsが、だいたいわかった: 2. 存在型(ExistentialQuantification拡張)の解説
=================================================================================

目次
----

0. [導入](../prelude.md)

1. [Freeモナドの概要](../free-monad/free-monad.md)
	* Freeモナドとは
	* FreeモナドでReaderモナド、Writerモナドを構成する
2. 存在型(ExistentialQuantification拡張)の解説
3. FreeモナドとCoyoneda
	* Coyonedaを使ってみる
	* FreeモナドとCoyonedaを組み合わせる
		+ いろいろなモナドを構成する
4. Freerモナド(Operationalモナド)でいろいろなモナドを構成する
	* FreeモナドとCoyonedaをまとめて、Freerモナドとする
	* Readerモナド
	* Writerモナド
	* 状態モナド
	* エラーモナド
5. モナドを混ぜ合わせる(閉じた型で)
	* Freerモナドで、状態モナドとエラーモナドを混ぜ合わせる
6. 存在型による拡張可能なデータ構造(Open Union)
7. モナドを混ぜ合わせる(開いた型で)
	* FreeモナドとOpen Unionを組み合わせる
	* 状態モナドにエラーモナドを追加する
8. Open Unionを型によって安全にする
9. Freer Effectsで、IOモナドなどの、既存のモナドを使用する
10. 関数を保管しておくデータ構造による効率化
11. いろいろなEffect
	* 関数handleRelayなどを作成する
	* NonDetについて、など

存在型が、なぜ存在型とよばれるか
--------------------------------

ここでは「存在型」の名前の理由を解説する。
実際に使用するときには、知らなくても問題ないので、
読みとばしてもかまわないかと思われる。

### 代数的データ型について

「代数的データ型が何をしているのか」について、考えてみよう。
つぎのような、定義があったとする。

```hs
data Foo = Foo Int
```

このとき、つぎの関数が定義されていると考えられる。

```hs
Foo :: Int -> Foo
```

しかし、それだけではない。
データ型FooからInt型の値を取り出すことを考えてみよう。

```hs
some (Foo x) = x
```

このようにパターンマッチを使う。
パターンマッチでしていることは、実は、つぎのような処理である。

```hs
unFoo :: Foo -> Int
```

つまり、代数的データ型Fooを定義するということは、
関数FooとunFooとを定義しているということだ。

```hs
data Foo = Foo Int

Foo :: Int -> Foo
unFoo :: Foo -> Int
```

### 全称量化と存在量化

演算子(.)の型を、みてみよう。

```hs
(.) :: (b -> c) -> (a -> b) -> a -> c
```

型変数a, b, cにはどのような型をいれてもいい。
つぎのような型は、演算子(.)の型として正しい。

```hs
(Int -> Bool) -> (String -> Int) -> String -> Bool
(Double -> Integer) -> (Char -> Double) -> Char -> Integer
```

つまり演算子(.)は「それぞれ、すべての型a, b, cについて」定義されている。
「すべての...について」とすることを、論理学の言葉で「全称量化」とよぶ。

	例1: 「すべてのxについて、xが10の倍数であれば、xは2の倍数である」

それに対して「ある...では...である」のようにすることを、「存在量化」とよぶ。

	例2: 「あるxについて、xは素数であり、かつ、xは偶数である」

おなじことを、より日常的な表現とすると、つぎのようになる。

	例2': 「素数であり、かつ、偶数であるようなxが存在する」

### 存在型

つぎのような代数的データ型を考える。

```hs
data Foo = Foo x
```

このような型は定義できない。
代数的データ型では、等号の左側にない型変数を、右側に置くことはできない。
GHCでは、ExistentialQuantification拡張を使い、かつ明示的に量化子forallを
つけることで、このような定義が可能となる。

```hs
data Foo = forall x . Foo x
```

つぎのような、ふたつの関数を定義したと考えることができる。

```hs
Foo :: forall x . x -> Foo
unFoo :: exists x . Foo -> x
```

実際にはexistsという量化子はHaskellには存在しない。
意味としては、つぎのようになる。

	すべての型xについてx型の値をFoo型の値に変換する関数Fooを定義
	Foo型の値から、なんらかの型xの値へ変換する関数unFooを定義

このあたりは、つぎの「箱」のイメージで理解できる。

	「何でもいれられる箱」から
	「取り出せるものは、何かしらの物」である

かりに、つぎのように、両方とも全称量化で定義されていると仮定する。

```hs
Foo :: forall x . x -> Foo
unFoo :: forall x . Foo -> x
```

すると、つぎのようになる。

	「何でもいれられる箱」からは
	「何でも取り出せる」

すべてのものを入れられる箱であっても、
その箱から、すべてのものが取り出せるわけではない。
すべてのものを入れられる箱から取り出せるのは、
「すべてのもの」のうちの「どれか」である。

Foo型の値を使った関数を考えてみよう。

```hs
useFoo :: Foo -> Int -> Bool
```

型Fooのなかに入っているのは、あらゆる型のうちの「どれか」である。
Fooという衣をはぐと、つぎのような型になる。

```hs
useFoo' :: exists x . x -> Int -> Bool
```

つまり、ExistentialQuantification拡張を使うと、
代数的データ型により、つつむことで、実質的には、存在量化された型変数を
使うことができるということになる。

存在型を使う
------------

これまでの説明では、「存在型がいったい何に使えるのか」は、わからない。
使用例をみていこう。

### どの型の値でも要素にできるリスト

### 表示できるものだけを含むリスト

### もとの型を取り出す

### もとの型を安全に取り出す

### 開かれた型

### 関数のリスト

### 途中経過を表示する

参考
----

[Wikibooks: Haskell/存在量化された型](https://ja.wikibooks.org/wiki/Haskell/%E5%AD%98%E5%9C%A8%E9%87%8F%E5%8C%96%E3%81%95%E3%82%8C%E3%81%9F%E5%9E%8B)
