memo
====

存在型が意味をもつ例
--------------------

1. 特定のクラスに属するという制限がある
	* かつ、なかみを取り出すための型の情報を別に保持している
2. 構成要素の引数と返り値とに、全称量化された型がある

具体例
------

1の例として、閉じた型に対応する開いた型を示す。
2の例として、...(考え中)...

### 考え中

たとえば、つぎのような型はどうだろうか。

```hs
data Cond a b = forall x . Cond (a -> x) (x -> b) (x -> b)
```

このようにしておいて、つぎのような関数を定義するとか。

```hs
cond :: Cond a b -> Bool -> a -> b
cond (Cond g f _) False = f . g
cond (Cond g _ f) True = f . g
```

どうかな?型変数xをforallにする必然性は、あるかな?
はじまりaと終わりbが、おなじ関数をリストにまとめられる、とか?

むしろ、関数リストのほうがいいかも。

data FunList a b = Id | forall x . (x -> b) :.: FunList a x

値構築子IdにGADTsが必要になるな。
やや美しさには劣るが、つぎのような定義はどうか。

data FunList a b = Fun (a -> b) | forall x . (x -> b) :.: FunList a x

こっちならExistentialQuantificationだけでできるな。
ただ、こういう関数のリストが、意味論的に「うれしい」のって何かあるかな?
効率とかの話ではなくて...

これ、xが全称量化されているから、「途中で打ち切る」という操作もできないし...

Endableクラスのインスタンスとして、それが出たら打ち切りにする、
とかいう操作も「まあまあ」役に立ちそうではあるか。

あとはCoyonedaの一歩手前くらいの例を挙げるのも、いいのかもしれない。
あるいは、CPSの例?でも、これはすこし大きな話になってしまうからなぁ。

(a -> x, x -> b)というタプルからの延長で、何かの機能を実現してみるというのは、
どうか。あるいは(x, x -> a)というタプルでば、どうか。
(t x, x -> a)では完全にCoyonedaになってしまうし...

大きなリストと重い計算での効率化の話は、遅延評価でなんとかなってしまうし。

途中の計算の結果を表示できる関数あたりかな。

全称量化と存在量化のいれかえ
----------------------------

まず、否定をいれると全称量化と存在量化はいれかわる。

	「すべてのxについて、xが素数ならば、xは奇数である」ではない
	あるxについて、xが素数かつ、xは奇数ではない

代数的データ型に値を「いれる」ときと「出す」ときとで、いれかわる。

	data Foo = forall x . Foo x

これを考える。

	「すべての型xについて、Foo xを定義することができる」
	「ある型xについてFoo xからxを取り出すことができる」

値構築子や取り出しの型を考えると、つぎのようになる。

	Foo :: forall x . x -> Foo
	unFoo :: exist x . Foo -> x

たとえば、つぎのような関数が書ける。

	some :: exist x . Foo -> x

つまり、Fooのなかみである値xの型は存在量化されていると言える。

	「すべてのxについて、この箱にはxを入れることができる」
	「あるxについて、この箱からxを取り出すことができる」

論理学的には、どのようになるだろうか。

	data Foo = Foo (exists x . x)

つぎの関係について考える。

	(exist x . P(x)) -> Q <=> all x . (P (x) -> Q)

	Pを満たすxがあれば、Qである
	すべてのxについて、「(どれかの?)xがPを満たせば、Qである」

これは、何かちがう気がするが。

	「ハンカチでもティッシュでも入れられる箱」から
	「取り出せるものはハンカチまたはティッシュ」である

ううむ...。

	Foo :: forall x . x -> Foo
	unFoo :: exists x . Foo -> x

	foo :: forall x . x -> f x
	unfoo :: forall x . f x -> x

たとえば、

	すべてのxについてP(x)ならばQである
	あるxについてQならばP(x)である

むしろ、こっちか

	all x . P(x) -> Q
	exists x . Q -> P(x)

これらを同時に定義しているということだ。
