タプルの要素を型で取り出す - 閉じた型シノニム族の使用例
=======================================================

対象読者
--------

* Haskellの初歩的な内容は理解した
* 以下の言語拡張のどちらかを使ったことがある、または、
		どちらかが使われたコードを読んだことがある
	+ FunctionalDependencies
	+ TypeFamilies
* 型演算という言葉が出てきても、動揺しない

はじめに
--------

型シノニム族(type synonym family)は、GHCのTypeFamilies拡張で使えるようになる
機能である。
型シノニムは型引数を取ることができるが、
標準では型引数は型変数のみだ。
たとえば、つぎのようになる。

```hs
type Foo x = Either String [Maybe x]
```

これは、型引数の指定により、型シノニムによって示される型の構造そのものは、
影響を受けないということだ。
型シノニム族の機能を使うと、つぎのような定義が可能になる。

```hs
type family Foo x

type instance Foo Integer = Maybe Integer
type instance Foo Char = Either Int Char
type instance Foo Bool = Double
```

型引数に具体的な型をとることができる。
結果として、型シノニムによって示される型の構造は、ばらばらになる。
つまり、型シノニム族の機能によって作られる型シノニムを使う場合、
たいていにおいて、パラメトリック多相関数ではなく、
型クラスを介したアドホック多相関数を使うことになる。

型シノニム族は、しばしば関数従属(FunctionalDependencies拡張)の
代替として使われるが、より広い用途を持ち、
型演算において中心的な役割を持っていると考えられる。

型シノニム族の定義には、新しい引数についての定義を、
自由に追加できる「開かれた型シノニム族(open type synonym family)」があり、
モジュールをまたいだ定義も可能となる。
一方、より制限された「閉じた型シノニム族(closed type synonym family)」
という定義のしかたもあり、
こちらでは、ひとつの型シノニム族に属する型シノニムは、
一ヶ所にまとめて定義しなくてはならない。

「閉じた型シノニム族」では、そのような制限によって、
逆に、できることが増えたという側面もある。
一ヶ所で定義できるということで、
型シノニムの定義を「うえから順に」試していくということが可能となる。
これは、つぎのような定義ができることを意味する。

```hs
type family Equal x y where
	Equal a a = 'True
	Equal a b = 'False
```

後者のパターンは、前者のパターンを含む。
よって、このような定義では、型シノニムの定義に「順番」をつけにくい
「開かれた型シノニム族」においては、
どちらの定義を選ぶかということの解決が難しくなる。

このような、定義の試される順番に依存した定義ができるのが、
「閉じた型システム」の大きな長所である。
この長所を生かしたサンプルコードを、ここで紹介する。

何を作るか
----------

タプルをヘテロリストとしてあつかい、
その要素を「型」によって取り出す。
ここで、ややこじつけではあるが、つぎの条件をつける。

* タプルのなかに、おなじ型の値が出てこない

ここでは、この条件を強制するのではなく、
推奨されている「この関数」を使ってもらうという、
ゆるいやりかたとする。
「新しい型を作る」「netypeでラップする」などの方法を使えば、
「強制」することは、かんたんだが、ここではサンプルコードの短さを優先する。

追加の言語拡張
--------------

### DataKinds

この拡張を使うと、値として定義された表現を「型」として使うことができる。
値を定義すると、型の世界にもおなじ形のものが生成される、といった感じだ。
たとえば、この拡張を使うと、値の世界でではなく、
型の世界でFalse, Trueといった
(途中)

### MultiParamTypeClasses

### FlexibleInstances
